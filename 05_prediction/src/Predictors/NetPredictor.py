import enum
import json
import logging
import re
from pathlib import Path

import cv2
import numpy as np
import segmentation_models
from keras.engine.saving import load_model
from tqdm import tqdm

from BaseObjects.Page import Page
from Predictors.Prediction import Prediction
from Predictors.Predictor import Predictor
from BaseObjects.Tile import Tiles


class NetPredictor(Predictor):
    def __init__(self, name, models_path, use_page_cache=False):
        if not re.match(r"^[a-z0-9/]+$", name):
            raise ValueError("illegal model name '%s'" % name)

        self._name = name
        self._page_cache = None

        models_path = Path(models_path)
        network_path = models_path / name

        for filename in ("meta.json", "model.h5"):
            asset_path = network_path / filename
            if not asset_path.exists():
                raise RuntimeError("no model file found at %s" % asset_path)

        # Loads the meta.json file in each part of the model. This is used to load and set
        # various attributes dynamically.
        with open(network_path / "meta.json", "r") as f:
            meta = json.loads(f.read())
        # Loads the types of labels that can be applied to the image
        classes = meta["classes"]

        if False:
            # Alternate loading method. Not tested
            model = getattr(segmentation_models, meta["model"])(
                meta["backbone"],
                classes=len(classes),
                activation="softmax")
            logging.info("loading model at %s" % str(network_path / "model.h5"))
            model.load_weights(str(network_path / "model.h5"))
        else:
            """Loads a Keras model from the specified path"""
            # see https://github.com/qubvel/segmentation_models/issues/153
            # see https://stackoverflow.com/questions/54835331/how-do-i-load-a-keras-saved-model-with-custom-optimizer
            model = load_model(str(network_path / "model.h5"), compile=False)

        # Loads the pre-processing backend for the segmentation model library.
        # What backend it is loading is defined in the meta.json in each saved model.
        self._preprocess = segmentation_models.get_preprocessing(meta["backbone"])

        self._model = model
        self._full_size = tuple(meta["full_size"])
        self._full_shape = tuple(reversed(self._full_size))
        self._tile_size = tuple(meta["tile_size"])

        # Generated a list of of Tile objects via the Tiles object callable method
        self._tiles = list(Tiles(
            self._tile_size,
            beta0=meta["tile_beta"])(meta["full_size"]))

        # Set the types of classes
        self._classes = enum.Enum(
            meta["type"] + "Label", dict((v, i) for i, v in enumerate(classes)))

        # Set the model type, Region or Separator
        self._type = meta["type"]

    @property
    def type(self):
        return self._type

    @property
    def classes(self):
        return self._classes

    @property
    def size(self):
        return self._full_size

    @property
    def tile_size(self):
        return self._tile_size

    def close(self):
        if self._cache:
            self._cache.close()

    def _predict(self, page: Page, labels=None, verbose=False) -> Prediction:
        """
        Inner function used to actually run the network against the input image.

        Args:
            page (): A page object representing the desired page to classify
            labels (): If labels are provided, classification is skipped and the values are simply returned
            verbose (): Optionally output more verbose information about the status of classification
        Returns:
            A Prediction object with the classes and labels generated by the classifier
        """
        if labels is None:
            # Re-size image using using pixel area relation
            net_input = cv2.resize(page.pixels, self._full_size, interpolation=cv2.INTER_AREA)
            # Convert from BGR -> RGB
            net_input = cv2.cvtColor(net_input, cv2.COLOR_BGR2RGB)
            # Pre-process the image using the loaded backbone of segmentation model library
            net_input = self._preprocess(net_input)

            labels = np.empty(self._full_shape, dtype=np.uint8)

            if verbose:
                tiles = tqdm(self._tiles, desc="prediction")
            else:
                tiles = self._tiles

            # Takes the list of Tile objects that are coordinates on how to divide the image
            # and then selects those pixels out from the input. Then, passing the actual image Tile(s) through
            # the predictor to obtain the labels.
            for tile in tiles:
                tile_pixels = tile.read_outer(net_input)
                # Insert dimension at axis 0
                tile_pixels = np.expand_dims(tile_pixels, axis=0)
                # Run model on this tile
                pr_mask = self._model.predict(tile_pixels)
                # TODO: BUT WHY?
                # Flattens along the last axis
                tile_labels = np.argmax(pr_mask.squeeze(), axis=-1).astype(np.uint8)
                # Write tile labels into labels array, which will represent the final output from the model
                # This writes the classified sections to the output data structure
                tile.write_inner(labels, tile_labels)

        # Wrap up all the data and return it as an object
        return Prediction(
            page,
            labels,
            self._classes)

    @property
    def background(self):
        return self._classes["BACKGROUND"]

    # Callable that actually runs the prediction against the input page
    def __call__(self, page, use_cache=True) -> Prediction:
        labels = None
        cache_key = self._name + "/" + page.key
        # Check if labels are already in cache
        if use_cache and self._page_cache is not None:
            if cache_key in self._page_cache:
                labels = self._page_cache[cache_key]
        # Run prediction
        prediction = self._predict(page, labels)

        if use_cache and labels is None and self._page_cache is not None:
            self._page_cache.set(cache_key, prediction.labels)

        return prediction
